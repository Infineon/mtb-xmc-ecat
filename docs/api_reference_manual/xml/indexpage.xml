<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>MTB-XMC-ECAT for ModusToolbox User Guide</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="index_1section_general">
<title>General Description</title>
<para><ulink url="https://github.com/Infineon/mtb-xmc-ecat">mtb-xmc-ecat</ulink> EtherCAT Middleware consists of all the elements necessary to start the EtherCAT slave development with the Beckhoff Slave Stack Code (SSC) including EtherCAT Slave Solution personality for the ModusToolbox<trademark/>.</para>
</sect1>
<sect1 id="index_1section_quick_start">
<title>Quick Start</title>
<para>The Quick Start Guide section has an example that demonstrates the implementation of the EtherCAT slave node using the Beckhoff SSC tool to generate the slave stack code for XMC4300 Relax EtherCAT Kit. <ulink url="https://www.infineon.com/cms/en/product/microcontroller/32-bit-industrial-microcontroller-based-on-arm-cortex-m/32-bit-xmc4000-industrial-microcontroller-arm-cortex-m4/xmc4300/">XMC4300 technical documentation</ulink></para>
<sect2 id="index_1section_qsg_project_creation">
<title>Project creation</title>
<para><orderedlist>
<listitem><para>Create a new ModusToolbox<trademark/> Application with KIT_XMC43_RELAX_ECAT_V1. And choose Empty Project.</para>
</listitem><listitem><para>Add the <ulink url="https://github.com/Infineon/mtb-xmc-ecat">mtb-xmc-ecat</ulink> and the <ulink url="https://github.com/Infineon/mtb-xmc-emeeprom">mtb-xmc-emeeprom</ulink> libraries using the Library Manager.</para>
</listitem><listitem><para>To run the example, install the required tools: TwinCAT3 Master PLC and Slave Stack Code Tool. This QSG was tested with SSC Tool version 5.13.</para>
</listitem><listitem><para>To set up the hardware, connect the Micro USB cable Debugger to X101 debug connector, and connect Ethernet cable to IN-port. Ensure that the XMC flash on your XMC4300 Relax EtherCAT Kit is cleaned up (Use J-Flash Lite for this).</para>
</listitem><listitem><para>At this stage, the project requires the EtherCAT slave stack code, which for the XMC4300 can be generated by configuration files already in the project. These configuration files are included in the project.</para>
</listitem></orderedlist>
</para>
</sect2>
<sect2 id="index_1section_qsg_project_gen_ssc">
<title>Generating Slave Stack Code and ESI file</title>
<para><orderedlist>
<listitem><para>Take the Excel Worksheet provided inside the example project to define your EtherCAT slave node interface. (After downloading the library through the Library Manager, you can find this file in the export folder.) The Beckhoff SSC-tool uses the excel sheet as an input to generate output-files. The generated EtherCAT slave stack code applies for XMC4300 and XMC4800. The generated EtherCAT Slave Information file (ESI) applies for the EtherCAT host, where the relevant interface information about the slave is stored.</para>
</listitem><listitem><para>Double click the excel file to open it. Check the content of the file. The data defined in both I/O directions is 4x16-bit integers and 8x1-bit booleans. For more details on how to define your own interface, refer the EtherCAT Slave Design Quick Guide.pdf inside the SSC tool.</para>
</listitem><listitem><para>Start the SSC Tool and create a new project: File &gt;&gt; New. Select the configuration file inside the example project and import it. Select the Infineon device inside the drop down list (Infineon XMC EtherCAT hardware) and click OK. Your project will be created.</para>
</listitem><listitem><para>Check the settings inside SlaveInformation: vendor ID, vendor name, product ID and product code are customer-specific and are used by the host to identify the slave. Define the revision number, serial number, device name, and HW/SW version per your needs. The vendor ID/name and product code assigned to Infineon may be used for the evaluation purpose only. For production, your own vendor ID/name assigned by the EtherCAT Technology Group is mandatory. <image type="html" name="slave_stack_tool.png"></image>
</para>
</listitem><listitem><para>Import the EXCEL-sheet, which defines the interface of your EtherCAT node. (After downloading the library through the Library Manager, you can find this file in the export folder.) Select the EXCEL-file provided inside the example project. Tool &gt;&gt; Application &gt;&gt; Import</para>
</listitem><listitem><para>Click Project &gt;&gt; Create new Slave Files to start file generation. Adapt the the destination folder for the EtherCAT slave Stack Code and the ESI file. For this example, the default settings are recommended.</para>
</listitem><listitem><para>Check the availability of the generated slave stack code. <image type="html" name="slave_stack_code.png"></image>
</para>
</listitem><listitem><para>Inside the generated file XMC_ESC.c, the link to your application must be implemented. Modify the source code accordingly, which copies the application data to/from ESC memory to the local application memory:</para>
</listitem></orderedlist>
</para>
<para><bold>BEFORE</bold> <image type="html" name="input_mapping_before.png"></image>
 <bold>AFTER</bold> <image type="html" name="input_mapping_after.png"></image>
 Code: <programlisting><codeline><highlight class="normal">memcpy(pData,&amp;(((UINT16<sp/>*)&amp;IN_GENERIC0x6000)[1]),SIZEOF(IN_GENERIC0x6000)-2);</highlight></codeline>
</programlisting></para>
<para><bold>BEFORE</bold> <image type="html" name="output_mapping_before.png"></image>
 <bold>AFTER</bold> <image type="html" name="output_mapping_after.png"></image>
 Code: <programlisting><codeline><highlight class="normal">memcpy(&amp;(((UINT16<sp/>*)&amp;OUT_GENERIC0x7000)[1]),pData,SIZEOF(OUT_GENERIC0x7000)-2);</highlight></codeline>
</programlisting></para>
<para>Inside the generated file XMC_ESC.c file, the function APPL_Application is implemented to handle the input and output. Inside main.c of the example, the function <programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>process_app(TOBJ7000<sp/>*OUT_GENERIC,<sp/>TOBJ6000<sp/>*IN_GENERIC);<sp/></highlight></codeline>
</programlisting> implements the mapping of the input/output data to buttons and LEDs. Therefore, modify the function APPL_Application to call process_app in the following way:</para>
<para><bold>BEFORE</bold> <image type="html" name="appl_before.png"></image>
 <bold>AFTER</bold> <image type="html" name="appl_after.png"></image>
 Code: <programlisting><codeline><highlight class="normal">process_app(&amp;OUT_GENERIC0x7000,<sp/>&amp;IN_GENERIC0x6000);<sp/></highlight></codeline>
</programlisting></para>
<para>Within the slave stack code, the function process_app is called. To process the binary output data (master -&gt; slave) to set the LED1 &quot;XMC4300 Relax EtherCAT Kit&quot;. The states of the BUTTON1 is checked and propagated to the input data (slave -&gt; master).</para>
</sect2>
<sect2 id="index_1section_qsg_project_dev_conf">
<title>HW Configuration in Device Configurator</title>
<para>HW resources used in this QSG must be configured in the Device Configurator:<itemizedlist>
<listitem><para>EtherCAT</para>
</listitem><listitem><para>CCU4 for timer</para>
</listitem><listitem><para>EEPROM</para>
</listitem><listitem><para>One pin for button and two LED pins</para>
</listitem></itemizedlist>
</para>
<para>If a different alias name is selected instead of the expected resources name in the Device Configurator, the code snippets must be updated.</para>
<para><table rows="5" cols="2"><row>
<entry thead="yes"><para>Resource</para>
</entry><entry thead="yes"><para>Name </para>
</entry></row>
<row>
<entry thead="no"><para>Led Pins </para>
</entry><entry thead="no"><para>CYBSP_USER_LED1/CYBSP_USER_LED2  </para>
</entry></row>
<row>
<entry thead="no"><para>Button Pin </para>
</entry><entry thead="no"><para>CYBSP_USER_BTN  </para>
</entry></row>
<row>
<entry thead="no"><para>ERU OGU for SYNC 0 </para>
</entry><entry thead="no"><para>ECAT_ERU_SYNC0  </para>
</entry></row>
<row>
<entry thead="no"><para>ERU OGU for SYNC 1 </para>
</entry><entry thead="no"><para>ECAT_ERU_SYNC1  </para>
</entry></row>
</table>
</para>
<para><bold>Recommended EtherCAT (ECAT) configuration</bold> <image type="html" name="ecatpins.png"></image>
 <image type="html" name="ecatprt2.png"></image>
 <bold>Recommended ECAT MII Port 0 configuration</bold> <image type="html" name="ecat_port0.png"></image>
 <bold>Recommended ECAT MII Port 1 configuration</bold> <image type="html" name="ecat_port1.png"></image>
 <bold>Recommended Button and Led Pins configuration</bold> <image type="html" name="button_pin.png"></image>
 <image type="html" name="button_config.png"></image>
 <image type="html" name="led_pins.png"></image>
 <image type="html" name="led_config.png"></image>
 <bold>The EVENT_DETECTOR, EVENT_GENERATOR and INTERRUPT APPs are used inside this example to connect the sync_out_0 and sync_out_1 of the ECAT_SSC APP to the interrupt service routines of the SSC-stack.</bold> <image type="html" name="eru_config.png"></image>
</para>
<para><simplesect kind="note"><para>After enabling the ECAT_SYNC0/ECAT_SYNC1 to ERU ERS you should do some additional steps (For example ECAT_SYNC0 connected to ERU1 ERS2):<orderedlist>
<listitem><para>Go to the ERU 1 ERS 2 and check that ERU 1 ETL 2 was assigned for Event Trigger Logic.</para>
</listitem><listitem><para>Go to the ERU 1 ETL2 and check that ERU 1 ERS 2 was assigned for Event Request Select Unit. Then, assign ERU 1 OGU to one of the 4 triggers. For example, assign ERU 1 OGU 0 to Trigger 0.</para>
</listitem><listitem><para>Go to all resources and find ERU 1 OGU 0 and give it the name: ECAT_ERU_SYNC0.</para>
</listitem></orderedlist>
</para>
</simplesect>
</para>
</sect2>
<sect2 id="index_1section_qsg_main">
<title>EtherCAT slave node code example</title>
<para><bold>Common code</bold><orderedlist>
<listitem><para>Include the required headers. <programlisting filename="QSG_code.c"><codeline><highlight class="preprocessor">#include<sp/>&quot;cybsp.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;cy_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;mtb_xmc_ecat.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;XMC_ESCObjects.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ecatappl.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;applInterface.h&quot;</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add the common define to the project. <programlisting filename="QSG_code.c"><codeline><highlight class="preprocessor">#define<sp/>MAP2LEVEL(x)<sp/>((x==0)?XMC_GPIO_OUTPUT_LEVEL_LOW:XMC_GPIO_OUTPUT_LEVEL_HIGH)</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add the function for data processing. <programlisting filename="QSG_code.c"><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>process_app(TOBJ7000<sp/>*<sp/>OUT_GENERIC,<sp/>TOBJ6000<sp/>*<sp/>IN_GENERIC)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>OUTPUT<sp/>PROCESSING<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>bitfield<sp/>set<sp/>by<sp/>master<sp/>OUT_GEN_Bit1..8<sp/>and<sp/>set<sp/>LEDs<sp/>accordingly<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>XMC_GPIO_SetOutputLevel(CYBSP_USER_LED1_PORT,<sp/>CYBSP_USER_LED1_PIN,<sp/>MAP2LEVEL(OUT_GENERIC-&gt;OUT_GEN_Bit1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>XMC_GPIO_SetOutputLevel(CYBSP_USER_LED2_PORT,<sp/>CYBSP_USER_LED2_PIN,<sp/>MAP2LEVEL(OUT_GENERIC-&gt;OUT_GEN_Bit2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>INPUT<sp/>PROCESSING<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Check<sp/>Button<sp/>1<sp/>and<sp/>set<sp/>IN_GEN_Bit1,<sp/>which<sp/>is<sp/>sent<sp/>to<sp/>master<sp/>accordingly*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XMC_GPIO_GetInput(CYBSP_USER_BTN1_PORT,<sp/>CYBSP_USER_BTN1_PIN))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IN_GENERIC-&gt;IN_GEN_Bit1<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IN_GENERIC-&gt;IN_GEN_Bit1<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add EtherCAT Interrupt Routine for SYNC0. <programlisting filename="QSG_code.c"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SYNC0IRQHandler(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sync0_Isr();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add EtherCAT Interrupt Routine for SYNC1. <programlisting filename="QSG_code.c"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SYNC1IRQHandler(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sync1_Isr();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add enabling of user-specific EtherCAT Interrupt Routines. <programlisting filename="QSG_code.c"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__group__ecat__functions_1gaeda7038680e2fa58ece91f53974b05d5" kindref="member">mtb_xmc_enable_user_int</ref>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>NVIC_EnableIRQ(ECAT_ERU_SYNC0_IRQN);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>NVIC_EnableIRQ(ECAT_ERU_SYNC1_IRQN);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add disabling of user-specific EtherCAT Interrupt Routines. <programlisting filename="QSG_code.c"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__group__ecat__functions_1ga96efe3f2f7d04809de2c41dbe99b672e" kindref="member">mtb_xmc_disable_user_int</ref>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>NVIC_DisableIRQ(ECAT_ERU_SYNC0_IRQN);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>NVIC_DisableIRQ(ECAT_ERU_SYNC1_IRQN);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Add the <ref refid="group__group__ecat__functions_1gaa242cdd50e00a5d4e3e33251c3d654d1" kindref="member">mtb_xmc_ecat_init()</ref> function to the main() after cybsp_init() function. <programlisting><codeline><highlight class="normal"><ref refid="group__group__ecat__functions_1gaa242cdd50e00a5d4e3e33251c3d654d1" kindref="member">mtb_xmc_ecat_init</ref>();<sp/></highlight></codeline>
</programlisting></para>
</listitem></orderedlist>
</para>
</sect2>
<sect2 id="index_1section_qsg_project_execution">
<title>Project execution</title>
<para><orderedlist>
<listitem><para>Build and program the project.</para>
</listitem><listitem><para>If the previous steps were correct, the Ethernet IN-port should be flashing.</para>
</listitem><listitem><para>After starting the TwinCAT System Manager from the Windows start menu. Right Click I/O-Devices and select &quot;Add New Item&quot;. Double-click it to create an EtherCAT master device.</para>
</listitem><listitem><para>Select and search the network adapter you want to use. <simplesect kind="note"><para>Application hint: If the device is not found, install the respective device driver - follow the instructions by TwinCAT, clicking the Compatible Devices button.</para>
</simplesect>
</para>
</listitem><listitem><para>Right-click the EtherCAT master and select &quot;Scan Boxes&quot;.</para>
</listitem><listitem><para>Now you can observe that the slave appears as a node on the EtherCAT master bus. The RUN-LED is flashing indicating the PREOP state.</para>
</listitem><listitem><para>EtherCAT master view: Inside the EtherCAT master online state you see the queued frames counting up, the connected slave and its PREOP state. EtherCAT slave view: The slave PREOP state is indicated within the TwinCAT system manager.</para>
</listitem><listitem><para>Set the master device to free run mode.</para>
</listitem><listitem><para>EtherCAT slave view: Online status of slave shows the slave in the OP state. EtherCAT master view: The master online status shows the slave in the OP state; Frames are not queued; Cyclic counter is incrementing. XMC4300 Relax EtherCAT Kit: RUN-LED is static turned on indicating the OP state.</para>
</listitem><listitem><para>While pushing BUTTON1 on XMC4300 Relax EtherCAT Kit, the button state is updated on the host. The IN_GEN_Bit1 state changes in accordance with the state of BUTTON1.</para>
</listitem><listitem><para>Right-click OUT_GEN_Bit1 of the slave node and select &quot;Online Write&quot; inside the context menu. Change the value from 0 to 1 to switch on LED1 from 1 to 0 to switch off LED1. LED1 XMC4300 Relax EtherCAT Kit is turned on/off according to the OUT_GEN_Bit1 setting.</para>
</listitem></orderedlist>
</para>
</sect2>
</sect1>
<sect1 id="index_1section_config_cons">
<title>Configuration Considerations</title>
<para><bold>General information</bold></para>
<para><orderedlist>
<listitem><para>This middleware has a personality that generates code called in the <ref refid="group__group__ecat__functions_1ga8e87560251ba1d0b3ab4f410c94b8190" kindref="member">HW_Init()</ref> function. <programlisting><codeline><highlight class="normal">MTB_XMC_ECAT_Initialization();<sp/></highlight></codeline>
</programlisting> In the <ref refid="group__group__ecat__functions_1ga8e87560251ba1d0b3ab4f410c94b8190" kindref="member">HW_Init()</ref> function, there are also set priorities for the ECAT and Timer and enable interrupts handling. You can select the priority for ECAT and Timer in the personality settings.</para>
</listitem><listitem><para>Functions <ref refid="group__group__ecat__functions_1gaa06b6c4b719e6c8535aa1cd525af5217" kindref="member">mtb_xmc_ecat_eeprom_init()</ref>, <ref refid="group__group__ecat__functions_1gab91c48d69b3bf7f8082ec958f93a9a59" kindref="member">mtb_xmc_ecat_timer_start()</ref> and <ref refid="group__group__ecat__functions_1ga8e87560251ba1d0b3ab4f410c94b8190" kindref="member">HW_Init()</ref> are provided but all of them are called in the <ref refid="group__group__ecat__functions_1gaa242cdd50e00a5d4e3e33251c3d654d1" kindref="member">mtb_xmc_ecat_init()</ref> function.</para>
</listitem></orderedlist>
</para>
<para><bold>Pins initialization</bold> To initialize the pins in this middleware, separate functions are used for each pin (the name of each function can be found in the preview code of the personality and they are distributed between the main and two port personalities). The recommended initialization sequence is shown below and you can see our realization in the <ref refid="group__group__ecat__functions_1ga8e87560251ba1d0b3ab4f410c94b8190" kindref="member">HW_Init()</ref> function but you can change it in your own way (optional):<orderedlist>
<listitem><para>gpio_init_p0_link_status();</para>
</listitem><listitem><para>gpio_init_p0_rxd3();</para>
</listitem><listitem><para>gpio_init_p0_rxd2();</para>
</listitem><listitem><para>gpio_init_p0_rxd1();</para>
</listitem><listitem><para>gpio_init_p0_rxd0();</para>
</listitem><listitem><para>gpio_init_p0_rx_dv();</para>
</listitem><listitem><para>gpio_init_p0_rx_clk();</para>
</listitem><listitem><para>gpio_init_p0_rx_err();</para>
</listitem><listitem><para>gpio_init_p0_tx_clk();</para>
</listitem><listitem><para>gpio_init_p1_link_status();</para>
</listitem><listitem><para>gpio_init_p1_rxd3();</para>
</listitem><listitem><para>gpio_init_p1_rxd2();</para>
</listitem><listitem><para>gpio_init_p1_rxd1();</para>
</listitem><listitem><para>gpio_init_p1_rxd0();</para>
</listitem><listitem><para>gpio_init_p1_rx_dv();</para>
</listitem><listitem><para>gpio_init_p1_rx_clk();</para>
</listitem><listitem><para>gpio_init_p1_rx_err();</para>
</listitem><listitem><para>gpio_init_p1_tx_clk();</para>
</listitem><listitem><para>gpio_init_ecat_mdio();</para>
</listitem></orderedlist>
</para>
<para>Then you should call this function: MTB_XMC_ECAT_Initialization();</para>
<para>And then you continue with pins initialization:<orderedlist>
<listitem><para>gpio_init_p0_txd3();</para>
</listitem><listitem><para>gpio_init_p0_txd2();</para>
</listitem><listitem><para>gpio_init_p0_txd1();</para>
</listitem><listitem><para>gpio_init_p0_txd0();</para>
</listitem><listitem><para>gpio_init_p0_tx_ena();</para>
</listitem><listitem><para>gpio_init_p1_txd3();</para>
</listitem><listitem><para>gpio_init_p1_txd2();</para>
</listitem><listitem><para>gpio_init_p1_txd1();</para>
</listitem><listitem><para>gpio_init_p1_txd0();</para>
</listitem><listitem><para>gpio_init_p1_tx_ena();</para>
</listitem><listitem><para>gpio_init_ecat_phy_clk25();</para>
</listitem><listitem><para>gpio_init_ecat_mclk();</para>
</listitem><listitem><para>gpio_init_p0_led_link_act();</para>
</listitem><listitem><para>gpio_init_p1_led_link_act();</para>
</listitem><listitem><para>gpio_init_ecat_led_run();</para>
</listitem><listitem><para>gpio_init_ecat_led_err();</para>
</listitem><listitem><para>gpio_init_ecat_phy_reset();</para>
</listitem></orderedlist>
</para>
<para><simplesect kind="note"><para>If you connect LATCHIN and SYNC signals to pins, don&apos;t forget to initialize their connection in your application using these functions as well:<orderedlist>
<listitem><para>gpio_init_ecat_latchin0();</para>
</listitem><listitem><para>gpio_init_ecat_latchin1();</para>
</listitem><listitem><para>gpio_init_ecat_sync0();</para>
</listitem><listitem><para>gpio_init_ecat_sync1();</para>
</listitem></orderedlist>
</para>
</simplesect>
<simplesect kind="note"><para>If you initialize only IN Port for ECAT and realize your own implementation of <ref refid="group__group__ecat__functions_1ga8e87560251ba1d0b3ab4f410c94b8190" kindref="member">HW_Init()</ref> function, you still need to use gpio_init_p1_link_status() function.</para>
</simplesect>
<bold>ECAT_TIMER_INT usage</bold></para>
<para>In the code, check is used if the ECAT_TIMER_INT define is set to 1. (The ECAT_TIMER_INT define is already set to 1 in the SSC_Config file, you can find it in the export folder. Also, you can change its value.) The code inside this condition executes and we call the ECAT_CheckTimer() function. If the switch ECAT_TIMER_INT is 0, the watchdog control is implemented without using interrupts. So, use the <ref refid="group__group__ecat__functions_1gafd2e227187852d4c570a293358ffcf60" kindref="member">HW_GetTimer()</ref> function.</para>
<para><simplesect kind="note"><para>1. The Middleware outputs a log using the XMC_ASSERT() function.</para>
</simplesect>
<simplesect kind="note"><para>2. This Middleware works only with the slave stack code generated by Beckhoff SSC tool. (Detailed instruction: <ref refid="index_1section_qsg_project_gen_ssc" kindref="member">Generating Slave Stack Code and ESI file</ref> section)</para>
</simplesect>
</para>
</sect1>
<sect1 id="index_1section_package_str">
<title>mtb-xmc-ecat Package Structure</title>
<para>The Middleware structure:<itemizedlist>
<listitem><para><bold>export:</bold> Contains configuration files for slave stack code generation.</para>
</listitem><listitem><para><bold>device-info:</bold> Contains an EtherCAT personality.</para>
</listitem><listitem><para><bold>docs:</bold> Contains the API Reference Guide, mtb-xmc-ecat User Guide &amp; Reference Manual and other supporting documentation.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1section_mtb_xmc_ecat_changelog">
<title>Changelog</title>
<para><table rows="3" cols="3"><row>
<entry thead="yes"><para>Version</para>
</entry><entry thead="yes"><para>Changes</para>
</entry><entry thead="yes"><para>Reason for Change </para>
</entry></row>
<row>
<entry thead="no"><para>1.1.0 </para>
</entry><entry thead="no"><para>Added an ability to disable an output port. </para>
</entry><entry thead="no"><para>It was not possible to configure the ECAT only for the IN port.  </para>
</entry></row>
<row>
<entry thead="no"><para>1.0.0 </para>
</entry><entry thead="no"><para>Initial release of mtb-xmc-ecat middleware. </para>
</entry><entry thead="no"><para></para>
</entry></row>
</table>
</para>
</sect1>
    </detaileddescription>
    <location file="docs_src/mtb_xmc_ecat_overview.h"/>
  </compounddef>
</doxygen>
