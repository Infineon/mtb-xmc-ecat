<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB XMC ECAT Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB XMC ECAT Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MTB-XMC-ECAT for ModusToolbox User Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="section_general"></a>
General Description</h1>
<p ><a href="https://github.com/Infineon/mtb-xmc-ecat">mtb-xmc-ecat</a> EtherCAT Middleware consists of all the elements necessary to start the EtherCAT slave development with the Beckhoff Slave Stack Code (SSC) including EtherCAT Slave Solution personality for the ModusToolbox&trade;.</p>
<h1><a class="anchor" id="section_quick_start"></a>
Quick Start</h1>
<p >The Quick Start Guide section has an example that demonstrates the implementation of the EtherCAT slave node using the Beckhoff SSC tool to generate the slave stack code for XMC4300 Relax EtherCAT Kit. <a href="https://www.infineon.com/cms/en/product/microcontroller/32-bit-industrial-microcontroller-based-on-arm-cortex-m/32-bit-xmc4000-industrial-microcontroller-arm-cortex-m4/xmc4300/">XMC4300 technical documentation</a></p>
<h2><a class="anchor" id="section_qsg_project_creation"></a>
Project creation</h2>
<ol type="1">
<li>Create a new ModusToolbox&trade; Application with KIT_XMC43_RELAX_ECAT_V1. And choose Empty Project.</li>
<li>Add the <a href="https://github.com/Infineon/mtb-xmc-ecat">mtb-xmc-ecat</a> and the <a href="https://github.com/Infineon/mtb-xmc-emeeprom">mtb-xmc-emeeprom</a> libraries using the Library Manager.</li>
<li>To run the example, install the required tools: TwinCAT3 Master PLC and Slave Stack Code Tool. This QSG was tested with SSC Tool version 5.13.</li>
<li>To set up the hardware, connect the Micro USB cable Debugger to X101 debug connector, and connect Ethernet cable to IN-port. Ensure that the XMC flash on your XMC4300 Relax EtherCAT Kit is cleaned up (Use J-Flash Lite for this).</li>
<li>At this stage, the project requires the EtherCAT slave stack code, which for the XMC4300 can be generated by configuration files already in the project. These configuration files are included in the project.</li>
</ol>
<h2><a class="anchor" id="section_qsg_project_gen_ssc"></a>
Generating Slave Stack Code and ESI file</h2>
<ol type="1">
<li>Take the Excel Worksheet provided inside the example project to define your EtherCAT slave node interface. (After downloading the library through the Library Manager, you can find this file in the export folder.) The Beckhoff SSC-tool uses the excel sheet as an input to generate output-files. The generated EtherCAT slave stack code applies for XMC4300 and XMC4800. The generated EtherCAT Slave Information file (ESI) applies for the EtherCAT host, where the relevant interface information about the slave is stored.</li>
<li>Double click the excel file to open it. Check the content of the file. The data defined in both I/O directions is 4x16-bit integers and 8x1-bit booleans. For more details on how to define your own interface, refer the EtherCAT Slave Design Quick Guide.pdf inside the SSC tool.</li>
<li>Start the SSC Tool and create a new project: File &gt;&gt; New. Select the configuration file inside the example project and import it. Select the Infineon device inside the drop down list (Infineon XMC EtherCAT hardware) and click OK. Your project will be created.</li>
<li>Check the settings inside SlaveInformation: vendor ID, vendor name, product ID and product code are customer-specific and are used by the host to identify the slave. Define the revision number, serial number, device name, and HW/SW version per your needs. The vendor ID/name and product code assigned to Infineon may be used for the evaluation purpose only. For production, your own vendor ID/name assigned by the EtherCAT Technology Group is mandatory. <div class="image">
<img src="slave_stack_tool.png" alt=""/>
</div>
</li>
<li>Import the EXCEL-sheet, which defines the interface of your EtherCAT node. (After downloading the library through the Library Manager, you can find this file in the export folder.) Select the EXCEL-file provided inside the example project. Tool &gt;&gt; Application &gt;&gt; Import</li>
<li>Click Project &gt;&gt; Create new Slave Files to start file generation. Adapt the the destination folder for the EtherCAT slave Stack Code and the ESI file. For this example, the default settings are recommended.</li>
<li>Check the availability of the generated slave stack code. <div class="image">
<img src="slave_stack_code.png" alt=""/>
</div>
</li>
<li>Inside the generated file XMC_ESC.c, the link to your application must be implemented. Modify the source code accordingly, which copies the application data to/from ESC memory to the local application memory:</li>
</ol>
<p ><b>BEFORE</b> </p><div class="image">
<img src="input_mapping_before.png" alt=""/>
</div>
<p> <b>AFTER</b> </p><div class="image">
<img src="input_mapping_after.png" alt=""/>
</div>
<p> Code: </p><div class="fragment"><div class="line">memcpy(pData,&amp;(((UINT16 *)&amp;IN_GENERIC0x6000)[1]),SIZEOF(IN_GENERIC0x6000)-2);</div>
</div><!-- fragment --><p ><b>BEFORE</b> </p><div class="image">
<img src="output_mapping_before.png" alt=""/>
</div>
<p> <b>AFTER</b> </p><div class="image">
<img src="output_mapping_after.png" alt=""/>
</div>
<p> Code: </p><div class="fragment"><div class="line">memcpy(&amp;(((UINT16 *)&amp;OUT_GENERIC0x7000)[1]),pData,SIZEOF(OUT_GENERIC0x7000)-2);</div>
</div><!-- fragment --><p >Inside the generated file XMC_ESC.c file, the function APPL_Application is implemented to handle the input and output. Inside main.c of the example, the function </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> process_app(TOBJ7000 *OUT_GENERIC, TOBJ6000 *IN_GENERIC); </div>
</div><!-- fragment --><p> implements the mapping of the input/output data to buttons and LEDs. Therefore, modify the function APPL_Application to call process_app in the following way:</p>
<p ><b>BEFORE</b> </p><div class="image">
<img src="appl_before.png" alt=""/>
</div>
<p> <b>AFTER</b> </p><div class="image">
<img src="appl_after.png" alt=""/>
</div>
<p> Code: </p><div class="fragment"><div class="line">process_app(&amp;OUT_GENERIC0x7000, &amp;IN_GENERIC0x6000); </div>
</div><!-- fragment --><p >Within the slave stack code, the function process_app is called. To process the binary output data (master -&gt; slave) to set the LED1 "XMC4300 Relax EtherCAT Kit". The states of the BUTTON1 is checked and propagated to the input data (slave -&gt; master).</p>
<h2><a class="anchor" id="section_qsg_project_dev_conf"></a>
HW Configuration in Device Configurator</h2>
<p >HW resources used in this QSG must be configured in the Device Configurator:</p><ul>
<li>EtherCAT</li>
<li>CCU4 for timer</li>
<li>EEPROM</li>
<li>One pin for button and two LED pins</li>
</ul>
<p >If a different alias name is selected instead of the expected resources name in the Device Configurator, the code snippets must be updated.</p>
<table class="doxtable">
<tr>
<th>Resource</th><th>Name </th></tr>
<tr>
<td>Led Pins </td><td>CYBSP_USER_LED1/CYBSP_USER_LED2  </td></tr>
<tr>
<td>Button Pin </td><td>CYBSP_USER_BTN  </td></tr>
<tr>
<td>ERU OGU for SYNC 0 </td><td>ECAT_ERU_SYNC0  </td></tr>
<tr>
<td>ERU OGU for SYNC 1 </td><td>ECAT_ERU_SYNC1  </td></tr>
</table>
<p ><b>Recommended EtherCAT (ECAT) configuration</b> </p><div class="image">
<img src="ecatpins.png" alt=""/>
</div>
 <div class="image">
<img src="ecatprt2.png" alt=""/>
</div>
<p> <b>Recommended ECAT MII Port 0 configuration</b> </p><div class="image">
<img src="ecat_port0.png" alt=""/>
</div>
<p> <b>Recommended ECAT MII Port 1 configuration</b> </p><div class="image">
<img src="ecat_port1.png" alt=""/>
</div>
<p> <b>Recommended Button and Led Pins configuration</b> </p><div class="image">
<img src="button_pin.png" alt=""/>
</div>
 <div class="image">
<img src="button_config.png" alt=""/>
</div>
 <div class="image">
<img src="led_pins.png" alt=""/>
</div>
 <div class="image">
<img src="led_config.png" alt=""/>
</div>
<p> <b>The EVENT_DETECTOR, EVENT_GENERATOR and INTERRUPT APPs are used inside this example to connect the sync_out_0 and sync_out_1 of the ECAT_SSC APP to the interrupt service routines of the SSC-stack.</b> </p><div class="image">
<img src="eru_config.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd>After enabling the ECAT_SYNC0/ECAT_SYNC1 to ERU ERS you should do some additional steps (For example ECAT_SYNC0 connected to ERU1 ERS2):<ol type="1">
<li>Go to the ERU 1 ERS 2 and check that ERU 1 ETL 2 was assigned for Event Trigger Logic.</li>
<li>Go to the ERU 1 ETL2 and check that ERU 1 ERS 2 was assigned for Event Request Select Unit. Then, assign ERU 1 OGU to one of the 4 triggers. For example, assign ERU 1 OGU 0 to Trigger 0.</li>
<li>Go to all resources and find ERU 1 OGU 0 and give it the name: ECAT_ERU_SYNC0.</li>
</ol>
</dd></dl>
<h2><a class="anchor" id="section_qsg_main"></a>
EtherCAT slave node code example</h2>
<p ><b>Common code</b></p><ol type="1">
<li>Include the required headers. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cybsp.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cy_utils.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;mtb_xmc_ecat.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;XMC_ESCObjects.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ecatappl.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;applInterface.h&quot;</span></div>
</div><!-- fragment --></li>
<li>Add the common define to the project. <div class="fragment"><div class="line"><span class="preprocessor">#define MAP2LEVEL(x) ((x==0)?XMC_GPIO_OUTPUT_LEVEL_LOW:XMC_GPIO_OUTPUT_LEVEL_HIGH)</span></div>
</div><!-- fragment --></li>
<li>Add the function for data processing. <div class="fragment"><div class="line"><span class="keywordtype">void</span> process_app(TOBJ7000 * OUT_GENERIC, TOBJ6000 * IN_GENERIC)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* OUTPUT PROCESSING */</span></div>
<div class="line">    <span class="comment">/* Check bitfield set by master OUT_GEN_Bit1..8 and set LEDs accordingly */</span></div>
<div class="line">    XMC_GPIO_SetOutputLevel(CYBSP_USER_LED1_PORT, CYBSP_USER_LED1_PIN, MAP2LEVEL(OUT_GENERIC-&gt;OUT_GEN_Bit1));</div>
<div class="line">    XMC_GPIO_SetOutputLevel(CYBSP_USER_LED2_PORT, CYBSP_USER_LED2_PIN, MAP2LEVEL(OUT_GENERIC-&gt;OUT_GEN_Bit2));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* INPUT PROCESSING */</span></div>
<div class="line">    <span class="comment">/*Check Button 1 and set IN_GEN_Bit1, which is sent to master accordingly*/</span></div>
<div class="line">    <span class="keywordflow">if</span> (XMC_GPIO_GetInput(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN))</div>
<div class="line">    {</div>
<div class="line">        IN_GENERIC-&gt;IN_GEN_Bit1 = 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        IN_GENERIC-&gt;IN_GEN_Bit1 = 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --></li>
<li>Add EtherCAT Interrupt Routine for SYNC0. <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SYNC0IRQHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Sync0_Isr();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --></li>
<li>Add EtherCAT Interrupt Routine for SYNC1. <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SYNC1IRQHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Sync1_Isr();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --></li>
<li>Add enabling of user-specific EtherCAT Interrupt Routines. <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__group__ecat__functions.html#gaeda7038680e2fa58ece91f53974b05d5">mtb_xmc_enable_user_int</a>()</div>
<div class="line">{</div>
<div class="line">    NVIC_EnableIRQ(ECAT_ERU_SYNC0_IRQN);</div>
<div class="line">    NVIC_EnableIRQ(ECAT_ERU_SYNC1_IRQN);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__ecat__functions_html_gaeda7038680e2fa58ece91f53974b05d5"><div class="ttname"><a href="group__group__ecat__functions.html#gaeda7038680e2fa58ece91f53974b05d5">mtb_xmc_enable_user_int</a></div><div class="ttdeci">__WEAK void mtb_xmc_enable_user_int(void)</div><div class="ttdef"><b>Definition:</b> mtb_xmc_ecat.c:201</div></div>
</div><!-- fragment --></li>
<li>Add disabling of user-specific EtherCAT Interrupt Routines. <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__group__ecat__functions.html#ga96efe3f2f7d04809de2c41dbe99b672e">mtb_xmc_disable_user_int</a>()</div>
<div class="line">{</div>
<div class="line">    NVIC_DisableIRQ(ECAT_ERU_SYNC0_IRQN);</div>
<div class="line">    NVIC_DisableIRQ(ECAT_ERU_SYNC1_IRQN);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__ecat__functions_html_ga96efe3f2f7d04809de2c41dbe99b672e"><div class="ttname"><a href="group__group__ecat__functions.html#ga96efe3f2f7d04809de2c41dbe99b672e">mtb_xmc_disable_user_int</a></div><div class="ttdeci">__WEAK void mtb_xmc_disable_user_int(void)</div><div class="ttdef"><b>Definition:</b> mtb_xmc_ecat.c:207</div></div>
</div><!-- fragment --></li>
<li>Add the <a class="el" href="group__group__ecat__functions.html#gaa242cdd50e00a5d4e3e33251c3d654d1">mtb_xmc_ecat_init()</a> function to the main() after cybsp_init() function. <div class="fragment"><div class="line"><a class="code hl_function" href="group__group__ecat__functions.html#gaa242cdd50e00a5d4e3e33251c3d654d1">mtb_xmc_ecat_init</a>(); </div>
<div class="ttc" id="agroup__group__ecat__functions_html_gaa242cdd50e00a5d4e3e33251c3d654d1"><div class="ttname"><a href="group__group__ecat__functions.html#gaa242cdd50e00a5d4e3e33251c3d654d1">mtb_xmc_ecat_init</a></div><div class="ttdeci">uint32_t mtb_xmc_ecat_init(void)</div><div class="ttdef"><b>Definition:</b> mtb_xmc_ecat.c:171</div></div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="section_qsg_project_execution"></a>
Project execution</h2>
<ol type="1">
<li>Build and program the project.</li>
<li>If the previous steps were correct, the Ethernet IN-port should be flashing.</li>
<li>After starting the TwinCAT System Manager from the Windows start menu. Right Click I/O-Devices and select "Add New Item". Double-click it to create an EtherCAT master device.</li>
<li>Select and search the network adapter you want to use. <dl class="section note"><dt>Note</dt><dd>Application hint: If the device is not found, install the respective device driver - follow the instructions by TwinCAT, clicking the Compatible Devices button.</dd></dl>
</li>
<li>Right-click the EtherCAT master and select "Scan Boxes".</li>
<li>Now you can observe that the slave appears as a node on the EtherCAT master bus. The RUN-LED is flashing indicating the PREOP state.</li>
<li>EtherCAT master view: Inside the EtherCAT master online state you see the queued frames counting up, the connected slave and its PREOP state. EtherCAT slave view: The slave PREOP state is indicated within the TwinCAT system manager.</li>
<li>Set the master device to free run mode.</li>
<li>EtherCAT slave view: Online status of slave shows the slave in the OP state. EtherCAT master view: The master online status shows the slave in the OP state; Frames are not queued; Cyclic counter is incrementing. XMC4300 Relax EtherCAT Kit: RUN-LED is static turned on indicating the OP state.</li>
<li>While pushing BUTTON1 on XMC4300 Relax EtherCAT Kit, the button state is updated on the host. The IN_GEN_Bit1 state changes in accordance with the state of BUTTON1.</li>
<li>Right-click OUT_GEN_Bit1 of the slave node and select "Online Write" inside the context menu. Change the value from 0 to 1 to switch on LED1 from 1 to 0 to switch off LED1. LED1 XMC4300 Relax EtherCAT Kit is turned on/off according to the OUT_GEN_Bit1 setting.</li>
</ol>
<h1><a class="anchor" id="section_config_cons"></a>
Configuration Considerations</h1>
<p ><b>General information</b></p>
<ol type="1">
<li>This middleware has a personality that generates code called in the <a class="el" href="group__group__ecat__functions.html#ga8e87560251ba1d0b3ab4f410c94b8190">HW_Init()</a> function. <div class="fragment"><div class="line">MTB_XMC_ECAT_Initialization(); </div>
</div><!-- fragment --> In the <a class="el" href="group__group__ecat__functions.html#ga8e87560251ba1d0b3ab4f410c94b8190">HW_Init()</a> function, there are also set priorities for the ECAT and Timer and enable interrupts handling. You can select the priority for ECAT and Timer in the personality settings.</li>
<li>Functions <a class="el" href="group__group__ecat__functions.html#gaa06b6c4b719e6c8535aa1cd525af5217">mtb_xmc_ecat_eeprom_init()</a>, <a class="el" href="group__group__ecat__functions.html#gab91c48d69b3bf7f8082ec958f93a9a59">mtb_xmc_ecat_timer_start()</a> and <a class="el" href="group__group__ecat__functions.html#ga8e87560251ba1d0b3ab4f410c94b8190">HW_Init()</a> are provided but all of them are called in the <a class="el" href="group__group__ecat__functions.html#gaa242cdd50e00a5d4e3e33251c3d654d1">mtb_xmc_ecat_init()</a> function.</li>
</ol>
<p ><b>Pins initialization</b> To initialize the pins in this middleware, separate functions are used for each pin (the name of each function can be found in the preview code of the personality and they are distributed between the main and two port personalities). The recommended initialization sequence is shown below and you can see our realization in the <a class="el" href="group__group__ecat__functions.html#ga8e87560251ba1d0b3ab4f410c94b8190">HW_Init()</a> function but you can change it in your own way (optional):</p><ol type="1">
<li>gpio_init_p0_link_status();</li>
<li>gpio_init_p0_rxd3();</li>
<li>gpio_init_p0_rxd2();</li>
<li>gpio_init_p0_rxd1();</li>
<li>gpio_init_p0_rxd0();</li>
<li>gpio_init_p0_rx_dv();</li>
<li>gpio_init_p0_rx_clk();</li>
<li>gpio_init_p0_rx_err();</li>
<li>gpio_init_p0_tx_clk();</li>
<li>gpio_init_p1_link_status();</li>
<li>gpio_init_p1_rxd3();</li>
<li>gpio_init_p1_rxd2();</li>
<li>gpio_init_p1_rxd1();</li>
<li>gpio_init_p1_rxd0();</li>
<li>gpio_init_p1_rx_dv();</li>
<li>gpio_init_p1_rx_clk();</li>
<li>gpio_init_p1_rx_err();</li>
<li>gpio_init_p1_tx_clk();</li>
<li>gpio_init_ecat_mdio();</li>
</ol>
<p >Then you should call this function: MTB_XMC_ECAT_Initialization();</p>
<p >And then you continue with pins initialization:</p><ol type="1">
<li>gpio_init_p0_txd3();</li>
<li>gpio_init_p0_txd2();</li>
<li>gpio_init_p0_txd1();</li>
<li>gpio_init_p0_txd0();</li>
<li>gpio_init_p0_tx_ena();</li>
<li>gpio_init_p1_txd3();</li>
<li>gpio_init_p1_txd2();</li>
<li>gpio_init_p1_txd1();</li>
<li>gpio_init_p1_txd0();</li>
<li>gpio_init_p1_tx_ena();</li>
<li>gpio_init_ecat_phy_clk25();</li>
<li>gpio_init_ecat_mclk();</li>
<li>gpio_init_p0_led_link_act();</li>
<li>gpio_init_p1_led_link_act();</li>
<li>gpio_init_ecat_led_run();</li>
<li>gpio_init_ecat_led_err();</li>
<li>gpio_init_ecat_phy_reset();</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>If you connect LATCHIN and SYNC signals to pins, don't forget to initialize their connection in your application using these functions as well:<ol type="1">
<li>gpio_init_ecat_latchin0();</li>
<li>gpio_init_ecat_latchin1();</li>
<li>gpio_init_ecat_sync0();</li>
<li>gpio_init_ecat_sync1();</li>
</ol>
</dd></dl>
<p><b>ECAT_TIMER_INT usage</b></p>
<p >In the code, check is used if the ECAT_TIMER_INT define is set to 1. (The ECAT_TIMER_INT define is already set to 1 in the SSC_Config file, you can find it in the export folder. Also, you can change its value.) The code inside this condition executes and we call the ECAT_CheckTimer() function. If the switch ECAT_TIMER_INT is 0, the watchdog control is implemented without using interrupts. So, use the <a class="el" href="group__group__ecat__functions.html#gafd2e227187852d4c570a293358ffcf60">HW_GetTimer()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>1. The Middleware outputs a log using the XMC_ASSERT() function.</dd>
<dd>
2. This Middleware works only with the slave stack code generated by Beckhoff SSC tool. (Detailed instruction: <a class="el" href="index.html#section_qsg_project_gen_ssc">Generating Slave Stack Code and ESI file</a> section)</dd></dl>
<h1><a class="anchor" id="section_package_str"></a>
mtb-xmc-ecat Package Structure</h1>
<p >The Middleware structure:</p><ul>
<li><b>export:</b> Contains configuration files for slave stack code generation.</li>
<li><b>device-info:</b> Contains an EtherCAT personality.</li>
<li><b>docs:</b> Contains the API Reference Guide, mtb-xmc-ecat User Guide &amp; Reference Manual and other supporting documentation.</li>
</ul>
<h1><a class="anchor" id="section_mtb_xmc_ecat_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.0.0 </td><td>Initial release of mtb-xmc-ecat middleware. </td><td></td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB XMC ECAT Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
